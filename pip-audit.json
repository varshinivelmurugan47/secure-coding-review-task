{"dependencies": [{"name": "attrs", "version": "24.2.0", "vulns": []}, {"name": "bandit", "version": "1.7.5", "vulns": []}, {"name": "boltons", "version": "21.0.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "bracex", "version": "2.3.post1", "vulns": []}, {"name": "cachecontrol", "version": "0.14.0", "vulns": []}, {"name": "certifi", "version": "2025.11.12", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.4", "vulns": []}, {"name": "click", "version": "8.1.8", "vulns": []}, {"name": "click-option-group", "version": "0.5.9", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "cyclonedx-python-lib", "version": "4.2.3", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "face", "version": "24.0.0", "vulns": []}, {"name": "filelock", "version": "3.12.2", "vulns": []}, {"name": "flask", "version": "2.2.5", "vulns": []}, {"name": "gitdb", "version": "4.0.12", "vulns": []}, {"name": "gitpython", "version": "3.1.45", "vulns": []}, {"name": "glom", "version": "22.1.0", "vulns": []}, {"name": "html5lib", "version": "1.1", "vulns": []}, {"name": "idna", "version": "3.10", "vulns": []}, {"name": "importlib-metadata", "version": "6.7.0", "vulns": []}, {"name": "importlib-resources", "version": "5.12.0", "vulns": []}, {"name": "itsdangerous", "version": "2.1.2", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jsonschema", "version": "4.17.3", "vulns": []}, {"name": "license-expression", "version": "30.2.0", "vulns": []}, {"name": "markdown-it-py", "version": "2.2.0", "vulns": []}, {"name": "markupsafe", "version": "2.1.5", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "msgpack", "version": "1.0.5", "vulns": []}, {"name": "packageurl-python", "version": "0.15.6", "vulns": []}, {"name": "packaging", "version": "24.0", "vulns": []}, {"name": "pbr", "version": "7.0.3", "vulns": []}, {"name": "peewee", "version": "3.18.3", "vulns": []}, {"name": "pip", "version": "18.1", "vulns": [{"id": "PYSEC-2020-173", "fix_versions": ["19.2"], "description": "The pip package before 19.2 for Python allows Directory Traversal when a URL is given in an install command, because a Content-Disposition header can have ../ in a filename, as demonstrated by overwriting the /root/.ssh/authorized_keys file. This occurs in _download_http_url in _internal/download.py."}, {"id": "PYSEC-2021-437", "fix_versions": ["21.1"], "description": "A flaw was found in python-pip in the way it handled Unicode separators in git references. A remote attacker could possibly use this issue to install a different revision on a repository. The highest threat from this vulnerability is to data integrity. This is fixed in python-pip version 21.1."}, {"id": "PYSEC-2023-228", "fix_versions": ["23.3"], "description": "When installing a package from a Mercurial VCS URL  (ie \"pip install  hg+...\") with pip prior to v23.3, the specified Mercurial revision could  be used to inject arbitrary configuration options to the \"hg clone\"  call (ie \"--config\"). Controlling the Mercurial configuration can modify  how and which repository is installed. This vulnerability does not  affect users who aren't installing from Mercurial. "}, {"id": "GHSA-4xh5-x5gv-qwph", "fix_versions": ["25.3"], "description": "### Summary  In the fallback extraction path for source distributions, `pip` used Python\u2019s `tarfile` module without verifying that symbolic/hard link targets resolve inside the intended extraction directory. A malicious sdist can include links that escape the target directory and overwrite arbitrary files on the invoking host during `pip install`.  ### Impact  Successful exploitation enables arbitrary file overwrite outside the build/extraction directory on the machine running `pip`. This can be leveraged to tamper with configuration or startup files and may lead to further code execution depending on the environment, but the direct, guaranteed impact is integrity compromise on the vulnerable system.  ### Conditions  The issue is triggered when installing an attacker-controlled sdist (e.g., from an index or URL) and the fallback extraction code path is used. No special privileges are required beyond running `pip install`; active user action is necessary.  ### Remediation  The [fix](https://github.com/pypa/pip/pull/13550) is available starting in pip `25.3`. Using a Python interpreter that implements the safe-extraction behavior described by **PEP 706** provides additional defense in depth for other `tarfile` issues but is not a substitute for upgrading pip for this specific flaw."}]}, {"name": "pip-api", "version": "0.0.33", "vulns": []}, {"name": "pip-audit", "version": "2.6.1", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "pkgutil-resolve-name", "version": "1.3.10", "vulns": []}, {"name": "py-serializable", "version": "0.11.1", "vulns": []}, {"name": "pygments", "version": "2.17.2", "vulns": []}, {"name": "pyparsing", "version": "3.1.4", "vulns": []}, {"name": "pyrsistent", "version": "0.19.3", "vulns": []}, {"name": "python-lsp-jsonrpc", "version": "1.0.0", "vulns": []}, {"name": "pyyaml", "version": "6.0.1", "vulns": []}, {"name": "requests", "version": "2.31.0", "vulns": [{"id": "GHSA-9wx4-h78v-vm56", "fix_versions": ["2.32.0"], "description": "When making requests through a Requests `Session`, if the first request is made with `verify=False` to disable cert verification, all subsequent requests to the same origin will continue to ignore cert verification regardless of changes to the value of `verify`. This behavior will continue for the lifecycle of the connection in the connection pool.  ### Remediation Any of these options can be used to remediate the current issue, we highly recommend upgrading as the preferred mitigation.  * Upgrade to `requests>=2.32.0`. * For `requests<2.32.0`, avoid setting `verify=False` for the first request to a host while using a Requests Session. * For `requests<2.32.0`, call `close()` on `Session` objects to clear existing connections if `verify=False` is used.  ### Related Links * https://github.com/psf/requests/pull/6655"}, {"id": "GHSA-9hjg-9r4m-mvj7", "fix_versions": ["2.32.4"], "description": "### Impact  Due to a URL parsing issue, Requests releases prior to 2.32.4 may leak .netrc credentials to third parties for specific maliciously-crafted URLs.  ### Workarounds For older versions of Requests, use of the .netrc file can be disabled with `trust_env=False` on your Requests Session ([docs](https://requests.readthedocs.io/en/latest/api/#requests.Session.trust_env)).  ### References https://github.com/psf/requests/pull/6965 https://seclists.org/fulldisclosure/2025/Jun/2"}]}, {"name": "rich", "version": "13.8.1", "vulns": []}, {"name": "ruamel-yaml", "version": "0.17.40", "vulns": []}, {"name": "ruamel-yaml-clib", "version": "0.2.8", "vulns": []}, {"name": "semgrep", "version": "1.46.0", "vulns": []}, {"name": "setuptools", "version": "40.6.2", "vulns": [{"id": "PYSEC-2022-43012", "fix_versions": ["65.5.1"], "description": "Python Packaging Authority (PyPA) setuptools before 65.5.1 allows remote attackers to cause a denial of service via HTML in a crafted package or custom PackageIndex page. There is a Regular Expression Denial of Service (ReDoS) in package_index.py."}, {"id": "PYSEC-2025-49", "fix_versions": ["78.1.1"], "description": "setuptools is a package that allows users to download, build, install, upgrade, and uninstall Python packages. A path traversal vulnerability in `PackageIndex` is present in setuptools prior to version 78.1.1. An attacker would be allowed to write files to arbitrary locations on the filesystem with the permissions of the process running the Python code, which could escalate to remote code execution depending on the context. Version 78.1.1 fixes the issue."}, {"id": "GHSA-cx63-2mw6-8hw5", "fix_versions": ["70.0.0"], "description": "A vulnerability in the `package_index` module of pypa/setuptools versions up to 69.1.1 allows for remote code execution via its download functions. These functions, which are used to download packages from URLs provided by users or retrieved from package index servers, are susceptible to code injection. If these functions are exposed to user-controlled inputs, such as package URLs, they can execute arbitrary commands on the system. The issue is fixed in version 70.0."}]}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "smmap", "version": "5.0.2", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "stevedore", "version": "3.5.2", "vulns": []}, {"name": "toml", "version": "0.10.2", "vulns": []}, {"name": "tomli", "version": "2.0.1", "vulns": []}, {"name": "typing-extensions", "version": "4.7.1", "vulns": []}, {"name": "ujson", "version": "5.7.0", "vulns": []}, {"name": "urllib3", "version": "1.26.20", "vulns": [{"id": "GHSA-pq67-6m6q-mj2v", "fix_versions": ["2.5.0"], "description": "urllib3 handles redirects and retries using the same mechanism, which is controlled by the `Retry` object. The most common way to disable redirects is at the request level, as follows:  ```python resp = urllib3.request(\"GET\", \"https://httpbin.org/redirect/1\", redirect=False) print(resp.status) # 302 ```  However, it is also possible to disable redirects, for all requests, by instantiating a `PoolManager` and specifying `retries` in a way that disable redirects:  ```python import urllib3  http = urllib3.PoolManager(retries=0)  # should raise MaxRetryError on redirect http = urllib3.PoolManager(retries=urllib3.Retry(redirect=0))  # equivalent to the above http = urllib3.PoolManager(retries=False)  # should return the first response  resp = http.request(\"GET\", \"https://httpbin.org/redirect/1\") ```  However, the `retries` parameter is currently ignored, which means all the above examples don't disable redirects.  ## Affected usages  Passing `retries` on `PoolManager` instantiation to disable redirects or restrict their number.  By default, requests and botocore users are not affected.  ## Impact  Redirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects at the PoolManager level will remain vulnerable.  ## Remediation  You can remediate this vulnerability with the following steps:   * Upgrade to a patched version of urllib3. If your organization would benefit from the continued support of urllib3 1.x, please contact [sethmichaellarson@gmail.com](mailto:sethmichaellarson@gmail.com) to discuss sponsorship or contribution opportunities.  * Disable redirects at the `request()` level instead of the `PoolManager()` level."}]}, {"name": "wcmatch", "version": "8.4.1", "vulns": []}, {"name": "webencodings", "version": "0.5.1", "vulns": []}, {"name": "werkzeug", "version": "2.2.3", "vulns": [{"id": "PYSEC-2023-221", "fix_versions": ["2.3.8", "3.0.1"], "description": "Werkzeug is a comprehensive WSGI web application library. If an upload of a file that starts with CR or LF and then is followed by megabytes of data without these characters: all of these bytes are appended chunk by chunk into internal bytearray and lookup for boundary is performed on growing buffer. This allows an attacker to cause a denial of service by sending crafted multipart data to an endpoint that will parse it. The amount of CPU time required can block worker processes from handling legitimate requests. This vulnerability has been patched in version 3.0.1."}, {"id": "GHSA-2g68-c3qc-8985", "fix_versions": ["3.0.3"], "description": "The debugger in affected versions of Werkzeug can allow an attacker to execute code on a developer's machine under some circumstances. This requires the attacker to get the developer to interact with a domain and subdomain they control, and enter the debugger PIN, but if they are successful it allows access to the debugger even if it is only running on localhost. This also requires the attacker to guess a URL in the developer's application that will trigger the debugger."}, {"id": "GHSA-f9vj-2wh5-fj8j", "fix_versions": ["3.0.6"], "description": "On Python < 3.11 on Windows, `os.path.isabs()` does not catch UNC paths like `//server/share`. Werkzeug's `safe_join()` relies on this check, and so can produce a path that is not safe, potentially allowing unintended access to data. Applications using Python >= 3.11, or not using Windows, are not vulnerable."}, {"id": "GHSA-q34m-jh98-gwm2", "fix_versions": ["3.0.6"], "description": "Applications using Werkzeug to parse `multipart/form-data` requests are vulnerable to resource exhaustion. A specially crafted form body can bypass the `Request.max_form_memory_size` setting.   The `Request.max_content_length` setting, as well as resource limits provided by deployment software and platforms, are also available to limit the resources used during a request. This vulnerability does not affect those settings. All three types of limits should be considered and set appropriately when deploying an application."}]}, {"name": "zipp", "version": "3.15.0", "vulns": [{"id": "GHSA-jfmj-5v4g-7637", "fix_versions": ["3.19.1"], "description": "A Denial of Service (DoS) vulnerability exists in the jaraco/zipp library, affecting all versions prior to 3.19.1. The vulnerability is triggered when processing a specially crafted zip file that leads to an infinite loop. This issue also impacts the zipfile module of CPython, as features from the third-party zipp library are later merged into CPython, and the affected code is identical in both projects. The infinite loop can be initiated through the use of functions affecting the `Path` module in both zipp and zipfile, such as `joinpath`, the overloaded division operator, and `iterdir`. Although the infinite loop is not resource exhaustive, it prevents the application from responding. The vulnerability was addressed in version 3.19.1 of jaraco/zipp."}]}], "fixes": []}
